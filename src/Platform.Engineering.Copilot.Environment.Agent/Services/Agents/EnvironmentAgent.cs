using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Platform.Engineering.Copilot.Core.Interfaces.Agents;
using Platform.Engineering.Copilot.Core.Interfaces.Chat;
using Platform.Engineering.Copilot.Core.Services.Agents;
using Platform.Engineering.Copilot.Core.Models.Agents;

namespace Platform.Engineering.Copilot.Environment.Core;

/// <summary>
/// Specialized agent for environment management (lifecycle, cloning, scaling)
/// </summary>
public class EnvironmentAgent : ISpecializedAgent
{
    public AgentType AgentType => AgentType.Environment;

    private readonly Kernel _kernel;
    private readonly IChatCompletionService _chatCompletion;
    private readonly ILogger<EnvironmentAgent> _logger;
    private readonly EnvironmentManagementPlugin _environmentPlugin;

    public EnvironmentAgent(
        ISemanticKernelService semanticKernelService,
        ILogger<EnvironmentAgent> logger,
        EnvironmentManagementPlugin environmentPlugin)
    {
        _logger = logger;
        _environmentPlugin = environmentPlugin;
        
        // Create specialized kernel for environment operations
        _kernel = semanticKernelService.CreateSpecializedKernel(AgentType.Environment);
        _chatCompletion = _kernel.GetRequiredService<IChatCompletionService>();

        // Register environment management plugin
        _kernel.Plugins.Add(KernelPluginFactory.CreateFromObject(environmentPlugin, "EnvironmentManagementPlugin"));

        _logger.LogInformation("‚úÖ Environment Agent initialized with specialized kernel");
    }

    public async Task<AgentResponse> ProcessAsync(AgentTask task, SharedMemory memory)
    {
        _logger.LogInformation("üåç Environment Agent processing task: {TaskId}", task.TaskId);

        var startTime = DateTime.UtcNow;
        var response = new AgentResponse
        {
            TaskId = task.TaskId,
            AgentType = AgentType.Environment,
            Success = false
        };

        try
        {
            // Get conversation context from shared memory
            var context = memory.GetContext(task.ConversationId ?? "default");
            var previousResults = context?.PreviousResults ?? new List<AgentResponse>();

            // Build system prompt for environment management expertise
            var systemPrompt = BuildSystemPrompt();

            // Build user message with context
            var userMessage = BuildUserMessage(task, previousResults);

            // Create chat history
            var chatHistory = new ChatHistory();
            chatHistory.AddSystemMessage(systemPrompt);
            chatHistory.AddUserMessage(userMessage);

            // üî• Set conversation ID in plugin so it can retrieve files from SharedMemory
            // This enables EnvironmentAgent to retrieve Bicep templates generated by InfrastructureAgent
            _environmentPlugin.SetConversationId(task.ConversationId ?? "default");
            _logger.LogInformation(
                "üîó EnvironmentAgent: ConversationId set to {ConversationId} for SharedMemory file retrieval",
                task.ConversationId ?? "default");

            // Execute with moderate temperature for environment operations
            var executionSettings = new OpenAIPromptExecutionSettings
            {
                Temperature = 0.3, // Moderate temperature for precise operations
                MaxTokens = 4000,
                ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions
            };

            var result = await _chatCompletion.GetChatMessageContentAsync(
                chatHistory,
                executionSettings,
                _kernel);

            // üîç DIAGNOSTIC: Log what the LLM actually did
            _logger.LogInformation("üîç EnvironmentAgent DIAGNOSTIC:");
            _logger.LogInformation("   - Result Content Length: {Length} characters", result.Content?.Length ?? 0);
            _logger.LogInformation("   - Result Role: {Role}", result.Role);
            _logger.LogInformation("   - Result Metadata Keys: {Keys}", result.Metadata?.Keys != null ? string.Join(", ", result.Metadata.Keys) : "null");
            
            // Check if any functions were called
            if (result.Items != null && result.Items.Any())
            {
                _logger.LogInformation("   - Result Items Count: {Count}", result.Items.Count);
                foreach (var item in result.Items)
                {
                    _logger.LogInformation("     - Item Type: {Type}", item?.GetType().Name ?? "null");
                }
            }
            else
            {
                _logger.LogWarning("   ‚ö†Ô∏è  NO FUNCTION CALLS DETECTED - LLM returned text response only!");
                var preview = string.IsNullOrEmpty(result.Content) ? "empty" : result.Content.Substring(0, Math.Min(200, result.Content.Length));
                _logger.LogWarning("   üìù Response preview: {Preview}", preview);
            }

            response.Content = result.Content ?? "";
            response.Success = true;

            // Extract metadata
            response.Metadata = ExtractMetadata(result, task);

            // Store result in shared memory for other agents
            memory.AddAgentCommunication(
                task.ConversationId ?? "default",
                AgentType.Environment,
                AgentType.Orchestrator,
                $"Environment operation completed: {task.Description}",
                new Dictionary<string, object>
                {
                    ["result"] = result.Content ?? ""
                }
            );

            _logger.LogInformation("‚úÖ Environment Agent completed task: {TaskId}", task.TaskId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Environment Agent failed on task: {TaskId}", task.TaskId);
            response.Success = false;
            response.Errors = new List<string> { ex.Message };
        }

        response.ExecutionTimeMs = (int)(DateTime.UtcNow - startTime).TotalMilliseconds;
        return response;
    }

    private string BuildSystemPrompt()
    {
        return @"You are a specialized Environment Management expert with deep expertise in:

**Environment Lifecycle Management:**
- Environment provisioning and de-provisioning
- Environment cloning and replication
- Environment scaling (up/down, in/out)
- Environment health monitoring
- Environment state management

**Environment Types:**
- Development, Test, Staging, Production
- Sandbox and demo environments
- CI/CD pipeline environments
- Training and disaster recovery environments

**Best Practices:**
- Environment isolation and security boundaries
- Configuration management across environments
- Secrets and credentials management
- Environment naming conventions
- Resource tagging strategies

**Operations:**
- Clone existing environments with data/configuration
- Scale environments based on load and requirements
- Refresh environments with production data (sanitized)
- Environment status checks and health validation
- Environment cleanup and resource optimization

**CRITICAL: ALWAYS CALL FUNCTIONS - NEVER JUST RESPOND CONVERSATIONALLY!**

When your task description includes ANY of these keywords:
- ""Manage the environment lifecycle""
- ""Track the deployment""  
- ""Deploy"" or ""Provision""
- ""Create environment""
- ""Scale environment""
- ""Clone environment""

You MUST call the appropriate function! DO NOT just write a conversational response.

**ACTUAL DEPLOYMENT WORKFLOW:**
When your task is to ""Manage the environment lifecycle and track the deployment of the new resources"":

1. **YOU MUST CALL create_environment** - This is not optional!
2. The InfrastructureAgent already generated the Bicep templates in the previous step
3. Those templates are stored in SharedMemory and will be retrieved automatically
4. Your job is to ACTUALLY DEPLOY them by calling create_environment

**REQUIRED PARAMETERS FOR create_environment:**
- environmentName: Extract from task description (e.g., ""dev-aks"", ""staging-cluster"")
- environmentType: Use ""aks"" for Kubernetes, ""appservice"" for web apps, etc.
- resourceGroup: Extract from task or generate name (e.g., ""rg-dev-aks"")
- location: **CRITICAL - Azure Government ONLY regions**: usgovvirginia, usgovarizona, usgovtexas, usgoviowa, usdodeast, usdodcentral
  - ‚ùå WRONG: eastus, westus, centralus (commercial Azure regions - will FAIL in Azure Government!)
  - ‚úÖ CORRECT: usgovvirginia (default), usgovarizona
- subscriptionId: **ALWAYS REQUIRED** - Extract from task description or conversation

**CRITICAL: Subscription ID Requirement**
When creating environments with the create_environment function, you MUST ALWAYS provide the subscriptionId parameter.
- Extract the subscription ID from the user's request or previous conversation
- The subscription ID should be a valid Azure subscription GUID (format: 00000000-0000-0000-0000-000000000000)
- Never use placeholder values like 'default-subscription'
- The subscription ID will be visible in your task description or parameters

**Example - WRONG (Don't do this):**
Task: ""Manage the environment lifecycle and track the deployment of the new AKS cluster""
Response: ""I will manage the environment lifecycle and track the deployment...""  ‚ùå WRONG - No function call!

**Example - CORRECT (Do this):**
Task: ""Manage the environment lifecycle and track the deployment of the new AKS cluster in subscription 453c...""
Response: [Calls create_environment with environmentName=""dev-aks"", environmentType=""aks"", resourceGroup=""rg-dev-aks"", location=""usgovvirginia"", subscriptionId=""00000000-0000-0000-0000-000000000000""] ‚úÖ CORRECT

**DO NOT:**
- Write conversational responses without calling functions
- Say ""I will track..."" or ""I will manage..."" without actually calling create_environment
- Ask for more information if the subscription ID and basic details are in the task description
- Respond with status updates without first calling the deployment function

**DO:**
- Call create_environment IMMEDIATELY when your task is about deployment/provisioning
- Extract all necessary parameters from the task description and previous conversation context
- Trust that the Bicep templates are already in SharedMemory from InfrastructureAgent
- Actually execute the deployment by calling the function

Always provide clear operational steps and validate prerequisites before operations.

**ü§ñ Conversational Requirements Gathering**

When a user asks about environments, configurations, or deployments, use a conversational approach to gather context:

**For Environment Creation/Setup Requests, ask about:**
- **Environment Purpose**: ""What type of environment are you setting up?""
  - Development
  - Testing/QA
  - Staging
  - Production
  - Disaster Recovery
- **Naming Convention**: ""What naming pattern should I use?""
  - Standard: {app}-{env}-{region} (e.g., webapp-dev-eastus)
  - Custom pattern
  - User will provide full name
- **Location**: ""Which Azure region should I use?""
  - usgovvirginia (Azure Government)
  - usgovarizona (Azure Government)
  - Other Azure Government regions only
- **Subscription**: ""Which subscription should host this environment?""
  - Subscription ID or name
- **Resource Group**: ""Should I create a new resource group or use existing?""
  - Create new (suggest name based on environment)
  - Use existing (ask for name)

**For Environment Configuration Requests, ask about:**
- **Configuration Scope**: ""What would you like me to configure?""
  - Networking (VNets, subnets, NSGs)
  - Security (RBAC, managed identities, Key Vault)
  - Monitoring (Application Insights, Log Analytics)
  - Scaling (auto-scale rules, instance counts)
  - All of the above
- **Environment Type**: ""Which environment am I configuring?""
  - Environment name or ID
  - Check SharedMemory for recent deployments

**For Environment Validation Requests, ask about:**
- **Validation Level**: ""How thorough should the validation be?""
  - Basic (naming, tagging, RBAC, networking) - 4 checks
  - Standard (+ security, monitoring, backup, cost) - 9 checks
  - Comprehensive (+ compliance, DR, scaling, docs) - 16 checks
- **Environment ID**: ""Which environment should I validate?""
  - Environment name
  - Subscription + resource group combination
  - Check SharedMemory for recent deployments

**For Environment Comparison Requests, ask about:**
- **Environments to Compare**: ""Which two environments should I compare?""
  - Source environment (e.g., dev or staging)
  - Target environment (e.g., production)
- **Comparison Aspects**: ""What should I compare?""
  - Resource configuration (SKUs, sizes)
  - Network settings
  - Security configuration
  - Scaling settings
  - All of the above

**Example Conversation Flow:**

User: ""Set up a production environment for my new web app""
You: ""I'd be happy to help set up your production environment! To ensure everything is configured correctly, I need a few details:

1. What's the application name? (I'll use this for naming: {app}-prod-{region})
2. Which Azure region? (usgovvirginia, usgovarizona)
3. Which subscription should I use? (name or subscription ID)
4. What configuration level do you need?
   - Basic (compute + storage)
   - Standard (+ networking + security)
   - Enterprise (+ monitoring + compliance)

Let me know your preferences!""

User: ""webapp-api, usgovvirginia, subscription 453c..., enterprise""
You: **[IMMEDIATELY call create_environment function - DO NOT ask for confirmation]**

**CRITICAL: One Question Cycle Only!**
- First message: User asks to set up environment ‚Üí Ask for missing critical info
- Second message: User provides answers ‚Üí **IMMEDIATELY call the appropriate environment function**
- DO NOT ask ""Should I proceed?"" or ""Any adjustments needed?""
- DO NOT repeat questions - use smart defaults for minor missing details

**CRITICAL: Check SharedMemory First!**
Before asking for environment details, ALWAYS check SharedMemory for:
- Recently created environments
- Deployment metadata (resource group, subscription, location)
- If found, confirm with user: ""I found environment '{name}' from a recent deployment. Is this the one you want to configure/validate?""
";
    }

    private string BuildUserMessage(AgentTask task, List<AgentResponse> previousResults)
    {
        var message = $"Task: {task.Description}\n\n";

        // Add parameters if provided
        if (task.Parameters != null && task.Parameters.Any())
        {
            message += "Parameters:\n";
            foreach (var param in task.Parameters)
            {
                message += $"- {param.Key}: {param.Value}\n";
            }
            message += "\n";
        }

        // Add context from previous agent results
        if (previousResults.Any())
        {
            message += "Context from other agents:\n";
            foreach (var prevResult in previousResults.TakeLast(3))
            {
                var contentLength = prevResult.Content?.Length ?? 0;
                if (contentLength > 0)
                {
                    message += $"- {prevResult.AgentType}: {prevResult.Content?.Substring(0, Math.Min(200, contentLength))}...\n";
                }
            }
            message += "\n";
        }

        message += "Please perform the environment management operation with detailed status updates.";

        return message;
    }

    private Dictionary<string, object> ExtractMetadata(ChatMessageContent result, AgentTask task)
    {
        var metadata = new Dictionary<string, object>
        {
            ["timestamp"] = DateTime.UtcNow.ToString("O"),
            ["agentType"] = AgentType.Environment.ToString()
        };

        // Extract tool calls if any
        if (result.Metadata != null && result.Metadata.ContainsKey("ChatCompletionMessage"))
        {
            metadata["toolsInvoked"] = "EnvironmentManagementPlugin functions";
        }

        return metadata;
    }
}
